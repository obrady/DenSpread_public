---
title: "Summarize XGBoost in Brazil"
author: "Vinyas Harish"
date: "12/04/2021"
output: html_document
---

Setup workspace \~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Load in libraries, functions, data and do pre-processing}
knitr::opts_chunk$set(echo = TRUE)
#Basic loadins ####
rm(list = ls())
library(dplyr)
library(ggplot2)
library(sf)
library(RColorBrewer)
library(tidymodels)
library(plotly)
library(probably)
library(vip)
library(forcats)
library(tidyr)
library(tmap)
library(patchwork)
library(beepr)

source("Fx_computePerformanceMetrics.R")
source("Fx_tidyRegionalMetricsBra.R")
source("Fx_tidyYearlyMetricsBra.R")
source("Fx_NaiveTSCV.R")
source("Fx_timeseriesCV_short.R")
source("Fx_timeseriesCV_mediumBra.R")
source("Fx_computePerformanceMetrics.R")
source("Fx_generateSTSCVPredictions.R")
source("Fx_createChannelPlotDataframes.R")
source("Fx_predictIncidence.R")
source("Fx_minimizeClassificationDist.R")
source("Fx_computePerformanceMetricsNonIncidenceBasedThresholding.R")

bg <- c("all", "reporting")
bg <- "all"

# working directory
#setwd("/Users/Vinyas/OneDrive/08_Serotype_spread/")
setwd("/Users/eideobra/Dropbox/08_Serotype_spread/")

# load location data
load("Data/Intermediate_datasets/Brazil_location_data.RData")

# and admin shapefiles and trim to Brazil
admin1 <- read_sf(dsn = "Reference/Admin1(2011)/admin1.shp", layer = "admin1")
admin2 <- read_sf(dsn = "Reference/Admin2(2011)/admin2.shp", layer = "admin2")
admin1 = admin1[admin1$COUNTRY_ID == "BRA", ]
admin2 = dplyr::filter(admin2, COUNTRY_ID == "BRA")

#Load in fitting datasets

if(bg == "reporting"){
  load(file = "Data/Intermediate_datasets/Retrospective_pred/Spread_datasets_reportAs.RData")
}else{
  load(file = "Data/Intermediate_datasets/Retrospective_pred/Spread_datasets.RData")
}

# Brazil shapefile for visualisaiton
Brazil <- st_read("Reference/Admin2(2011)/admin2.shp")
Brazil = dplyr::filter(Brazil, COUNTRY_ID == "BRA")

# Dengue source locations (explanation in 02_Spread_model_fitting.R)
DEN_original_source = 9943

#Go from list into long dataframe
spread_dat = bind_rows(spread_dat)
spread_dat$Infected <- as.factor(spread_dat$Infected)

#Augment spread_dat with new variables ####
##Augmentation 1 -> Add in region for each GAUl obs #####
regions_states_LUT = data.frame(stringsAsFactors = FALSE, 
                                State=c("Acre", "Alagoas", "Amapa", "Amazonas", "Bahia", "Ceara", "Distrito Federal", "Espirito Santo","Goias","Maranhao","Mato Grosso","Mato Grosso Do Sul",
                                        "Minas Gerais", "Para","Paraiba","Parana","Pernambuco","Piaui", "Rio De Janeiro","Rio Grande Do Norte","Rio Grande Do Sul","Rondonia","Roraima",
                                        "Santa Catarina","Sao Paulo", "Sergipe", "Tocantins"),
                                Region = c("North","Northeast","North", "North", "Northeast", "Northeast", "CentralWest", "Southeast","CentralWest","Northeast",
                                           "CentralWest","CentralWest","Southeast", "North", "Northeast", "South", "Northeast", "Northeast", "Southeast", "Northeast", "South", "North",
                                           "North","South","Southeast", "Northeast","North"))
getRegion <- regions_states_LUT$Region
names(getRegion) <- regions_states_LUT$State

#Add region column to admin1 df
admin1$REGION <- NA
admin1 <- admin1 %>% mutate(REGION=getRegion[NAME])

#Add region column to spreaddat
spread_dat$Region <- ""
manuallyProcessedGAULs <- c(11839, 11840, 11841, 11842) #These have broken hierarchies in the shapefiles 

spread_dat$Region <- apply(spread_dat,1,function(row){
  municipality_GAUL <- as.numeric(row["GAUL"])
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  return(region_name)  
}) 
spread_dat <- spread_dat %>% mutate(Region = case_when(GAUL %in% manuallyProcessedGAULs ~ "North",
                                                       TRUE ~ as.character(Region)))
spread_dat$Region <- as.factor(spread_dat$Region)

##Augmentation 2 -> Add latitude and longitude for each GAUL obs ####
merged_data <- base::merge(spread_dat, location_data, by.x="GAUL", by.y="location")

#Replace the x and y columns in spread_dat with the x and y columns from location_data
spread_dat$x <- as.numeric(merged_data$x)
spread_dat$y <- as.numeric(merged_data$y)  

#Clean workspace for unnecessary variables
rm(merged_data)

##Augmentation 3 -> Denote eligibility for test Sets for each GAUL obs ####
#Get initial conditions from dat
#dat <- read.csv("/Users/Vinyas/OneDrive/08_Serotype_spread/Data/Brazil_mun_dat_cleaned_thresholded.csv")
dat <- read.csv("/Users/eideobra/Dropbox/08_Serotype_spread/Data/Brazil_mun_dat_cleaned_thresholded.csv")

#Get initial conditions
initialConditions <- dat %>% dplyr::filter( Year == 2001) %>% dplyr::select(GAUL)

yearlist <- list(2003, 2004, 2005, 2006, 2007, 2008, 2009,2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019)
dataByYear <- list()

#This is a sort of basecase
data02 <-  spread_dat %>% dplyr::filter(Year_end==2002) %>% mutate(TestElig = case_when(GAUL %in% initialConditions$GAUL ~ 0,
                                                                                 TRUE ~ 1))
dataByYear[[1]] <- data02

#Add in newly invaded regions in other years
for (year in yearlist){

infectedLastYear <- spread_dat %>% dplyr::filter(Year_end==(year-1) & Infected==1) %>% dplyr::select(GAUL)
infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==year & Infected==1) %>% dplyr::select(GAUL)
newlyInfectedRegions <- setdiff(infectedThisYear, infectedLastYear) 

#If a region is not infected yet, it is eligible for the test set 
#If a region is reported as infected, its only eligible if it wasn't infected in the previous year
newlyInfectedThisYear <- spread_dat %>% dplyr::filter(Year_end==year) %>% 
                                        mutate(TestElig = case_when(Infected==0 ~ 1,
                                                                    Infected == 1 & GAUL %in% newlyInfectedRegions$GAUL ~ 1,
                                                                    Infected == 1 & !(GAUL %in% newlyInfectedRegions$GAUL) ~ 0))

#Start filling at row 2
listIndex = year-2001
dataByYear[[listIndex]] <- newlyInfectedThisYear
}
spread_dat <- bind_rows(dataByYear)

#Clean workspace for unnecessary variables
rm(infectedLastYear,infectedThisYear,newlyInfectedRegions,newlyInfectedThisYear,yearlist,dataByYear,data02,listIndex)
```

```{r, Tune XGB - Last ran Dec 27 2023}
#Only run when there are updates to the dataset...
  # Note - This version is using the "MAX" version of spread_dat and addCovariates
set.seed(202212)
train_test_split <- initial_split(spread_dat,prop = 3/4, strata=Infected)
trainset_XGB <- training(train_test_split)
testset_XGB <- testing(train_test_split)
testset_XGB <- testset_XGB %>%dplyr::filter(TestElig==1)
  
folds <- vfold_cv(trainset_XGB, v=5)
  
#Create recipe where you exclude variables you do not want as predictors but keep in the dataset
xgb_rec <- recipe(Infected ~ ., data = trainset_XGB) %>%
             update_role(ae_suit, y, TCW_mean, LOGimport_pres_Grav,LOGimport_pres_GC,
                          Year_end,GAUL, TestElig, Region, new_role = "ID") %>% 
             step_normalize(x,LST_day_mean,LST_day_stdDev,LST_night_mean,LST_night_stdDev,TCW_stdDev,
                             EVI_mean,EVI_stdDev,Landcover,TCB_mean,TCB_stdDev,
                             LOGimport_pres_Fric,LOGimport_pres_Rad,import_pres_Adjacency, LOGimport_pres_Air,LOGimport_pres_Mig) 
  
#Specify an XGBoost model
xgb_spec_tuning <- boost_tree(min_n=tune(), 
                              tree_depth=tune(), 
                              learn_rate=tune(), 
                              loss_reduction=tune(), 
                              trees=tune(), 
                              mtry=tune(),
                              sample_size = tune(),
                              stop_iter = tune()) %>%
                   set_engine("xgboost") %>% 
                   set_mode("classification")
  
#Workflows combine model specifications and dataset recipes
xgb_tuning_wflow <- workflow() %>% 
                    add_recipe(xgb_rec) 
  
#Define the grid of hyperparameters and tune
xgboost_params <- parameters(min_n(),
                             tree_depth(),
                             learn_rate(),
                             loss_reduction(),
                             trees(),
                             stop_iter(),
                             finalize(mtry(c(1,16))),
                             sample_size = sample_prop(c(0.75, 0.99)))
  
xgboost_grid <- grid_max_entropy(xgboost_params, 
                                 size = 500)
  
doParallel::registerDoParallel()
  
tuningResults <- tune_grid(xgb_tuning_wflow %>% add_model(xgb_spec_tuning),
                           resamples = folds,
                           grid = xgboost_grid,
                           metrics=metric_set(roc_auc, bal_accuracy, j_index),
                           control = control_grid(verbose = TRUE, event_level = "second"))
  
#Updated workflow with tuned hyperparameters and check performance
xgb_highest_auc <- tuningResults %>% select_best("roc_auc")
xgb_highest_j <- tuningResults %>% select_best("j_index")

if(isTRUE(identical(xgb_highest_auc, xgb_highest_j))){
  print("Grid search found that the same set of hyperparameters could optimize for both max AUC and J-Index in the search space.")
}else{
  print(identical(xgb_highest_auc, xgb_highest_j))
}

xgb_tuned_wflow <- finalize_workflow(xgb_tuning_wflow %>% 
                                     add_model(xgb_spec_tuning),
                                     xgb_highest_auc) %>%
                   fit(data = trainset_XGB)
  
thresholdRange <- seq(0, 0.99, by = 0.01)
probThres <- minimizeClassificationDist(xgb_tuned_wflow, testset_XGB, thresholdRange)
  
#AUC/SP/SN overall, regionally, and yearly
metrics_xgb_Overall <- computePerformanceMetrics_NonIncidenceBasedThresholding(xgb_tuned_wflow, testset_XGB, probThres)

# runtime ~ overnight
```

```{r, Specify XGB parameters}
set.seed(202212)

#Create recipe where you exclude variables you do not want as predictors but keep in the dataset
xgb_rec <- recipe(Infected ~ ., data = spread_dat) %>%
             update_role(ae_suit, y, TCW_mean, LOGimport_pres_Grav,LOGimport_pres_GC,
                         Year_end,GAUL, TestElig, Region, new_role = "ID") %>% 
             step_normalize(x,LST_day_mean,LST_day_stdDev,LST_night_mean,LST_night_stdDev,TCW_stdDev,
                            EVI_mean,EVI_stdDev,Landcover,TCB_mean,TCB_stdDev,
                            LOGimport_pres_Fric,LOGimport_pres_Rad,import_pres_Adjacency, LOGimport_pres_Air,LOGimport_pres_Mig) 

#Specify an XGBoost model with previously tuned hyperparameters (as of Jan 15, 2023)
# unlist(xgb_highest_auc)
xgb_spec_pretuned <- boost_tree(mtry = 15,
                                min_n = 3, 
                                tree_depth = 15, 
                                learn_rate = 0.0302302539454393, 
                                loss_reduction = 	0.0579349229467861, 
                                trees = 1495,
                                sample_size = 0.882471508998424,
                                stop_iter = 18) %>%
                     set_engine("xgboost") %>% 
                     set_mode("classification")

#Workflows combine model specifications and dataset recipes
xgb_pretuned_wflow <- workflow() %>% 
                      add_recipe(xgb_rec) %>% 
                      add_model(xgb_spec_pretuned)
```

Shapley Value-Based Feature Importance\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Generate SHAP summary plot}
set.seed(202212)
library(SHAPforxgboost)
#Following the approach of: https://github.com/liuyanguu/SHAPforxgboost

#Since using the base XGB, pull out the XMat and YCol
xgb_X <- spread_dat %>% dplyr::select(-c(Infected, ae_suit, TCW_mean, LOGimport_pres_Grav,LOGimport_pres_GC,Year_end, Region, GAUL, y, TestElig)) %>%
                       dplyr::rename("Mean nighttime temp."="LST_night_mean",
                                     "Radiation"="LOGimport_pres_Rad",
                                     "Air travel"="LOGimport_pres_Air",
                                     "Migration"="LOGimport_pres_Mig",
                                     "Std dev daytime temp. "="LST_day_stdDev",
                                     "Mean env. veg. index"="EVI_mean",
                                     "Mean tassled cap brightness"="TCB_mean",
                                     "Mean daytime temp."="LST_day_mean",
                                     "Friction surface"="LOGimport_pres_Fric",
                                     "Std dev tassled cap brightness"="TCB_stdDev",
                                     "Std dev nighttime temp."="LST_night_stdDev",
                                     "Std dev env. veg. index"="EVI_stdDev",
                                     "Std dev tassled cap wetness"="TCW_stdDev",
                                     "Longitude"="x",
                                     "Adjacency"="import_pres_Adjacency")
xgb_y <- spread_dat %>% dplyr::select(Infected)

xgb_X <- as.matrix(xgb_X)
xgb_X <- scale(xgb_X,center = TRUE, scale = TRUE)

xgb_y <- as.matrix(xgb_y)

#Parameter conversion guide:  https://parsnip.tidymodels.org/reference/boost_tree.html
params <-list(objective = "binary:logistic",
              colsample_bynode = 0.9375, #mtry (15/16=0.9375)
              eta = 0.03023025, #learn_rate
              max_depth = 15, #tree_depth
              gamma = 0.05793492, #loss_reduction
              subsample = 0.8824715, #sample_size
              min_child_weight = 3) #min_n

mod <- xgboost::xgboost(data = xgb_X, label = xgb_y, 
                        params = params, 
                        nrounds = 1495, #trees
                        early_stopping_rounds = 18, #stop_iter
                        verbose = FALSE)

# To return the SHAP values and ranked features by mean|SHAP|
shap_values <- shap.values(xgb_model = mod, X_train = xgb_X)

# To prepare the long-format data:
shap_long <- shap.prep(xgb_model = mod, X_train = xgb_X)

# Create summary plot
label.feature <- function(x){
  # a saved list of some feature names that I am using
  labs <- SHAPforxgboost::labels_within_package
  # but if you supply your own `new_labels`, it will print your feature names
  # must provide a list.
  if (!is.null(new_labels)) {
    if(!is.list(new_labels)) {
      message("new_labels should be a list, for example,`list(var0 = 'VariableA')`.\n")
      }  else {
      message("Plot will use your user-defined labels.\n")
      labs = new_labels
      }
  }
  out <- rep(NA, length(x))
  for (i in 1:length(x)){
    if (is.null(labs[[ x[i] ]])){
      out[i] <- x[i]
    }else{
      out[i] <- labs[[ x[i] ]]
    }
  }
  return(out)
}

shap.plot.summary <- function(data_long, x_bound = NULL, dilute = FALSE, scientific = FALSE, my_format = NULL,
                              min_color_bound = "#FFCC33", max_color_bound = "#6600CC"){

  if (scientific){label_format = "%.1e"} else {label_format = "%.3f"}
  if (!is.null(my_format)) label_format <- my_format
  # check number of observations
  N_features <- data.table::setDT(data_long)[,data.table::uniqueN(variable)]
  if (is.null(dilute)) dilute = FALSE

  nrow_X <- nrow(data_long)/N_features # n per feature
  if (dilute!=0){
    # if nrow_X <= 10, no dilute happens
    dilute <- ceiling(min(nrow_X/10, abs(as.numeric(dilute)))) # not allowed to dilute to fewer than 10 obs/feature
    set.seed(1234)
    data_long <- data_long[sample(nrow(data_long),
                                  min(nrow(data_long)/dilute, nrow(data_long)/2))] # dilute
  }

  x_bound <- if (is.null(x_bound)) max(abs(data_long$value))*1.1 else as.numeric(abs(x_bound))
  plot1 <- ggplot(data = data_long) +
    coord_flip(ylim = c(-x_bound, x_bound)) +
    geom_hline(yintercept = 0) + # the y-axis beneath
    # sina plot:
    ggforce::geom_sina(aes(x = variable, y = value, color = stdfvalue),
              method = "counts", maxwidth = 0.7, alpha = 0.7) +
    scale_color_gradient(low=min_color_bound, high=max_color_bound,
                         breaks=c(0,1), labels=c(" Low", "High "),
                         guide = guide_colorbar(barwidth = 12, barheight = 0.3)) +
    theme_bw() +
    theme(axis.line.y = element_blank(),
          axis.ticks.y = element_blank(), # remove axis line
          legend.position="bottom",
          legend.title=element_text(size=10),
          legend.text=element_text(size=8),
          axis.title.x= element_text(size = 10)) +
    # reverse the order of features, from high to low
    # also relabel the feature using `label.feature`
    scale_x_discrete(limits = rev(levels(data_long$variable)),
                     labels = label.feature(rev(levels(data_long$variable))))+
    labs(y = "SHAP value (impact on model output)", x = "", color = "Feature value  ")
  return(plot1)
}

# save source data
write.csv(shap_long[, c("variable", "value", "stdfvalue")], 
          file = "/Users/eideobra/Dropbox/08_Serotype_spread/Figure_source_data/SD_Fig_3D.csv")

shap.plot.summary(shap_long)
```

```{r, Map the driving feature set within the contemporary data}
shapByGAUL <- shap_values$shap_score
shapByGAUL <- cbind(shapByGAUL, xgb_y, spread_dat$Year_end, spread_dat$TestElig, spread_dat$GAUL) %>% 
              rename("Year_end"="V3",
                     "TestElig"="V4",
                     "GAUL"="V5")

#Filter to only the year they first became invaded
shapByInvadedGAUL <- shapByGAUL %>% dplyr::filter(xgb_y == 1) %>%
                                    dplyr::filter(TestElig ==1) %>% 
                                    mutate(Env_Shap = `Mean env. veg. index` + 
                                                      `Std dev env. veg. index` +
                                                       Landcover +
                                                       `Mean daytime temp.`+
                                                       `Std dev daytime temp. `+
                                                      `Mean nighttime temp.`+
                                                      `Std dev nighttime temp.`+
                                                      `Mean tassled cap brightness`+
                                                      `Std dev tassled cap brightness`+
                                                      `Std dev tassled cap wetness`+
                                                      Longitude) %>%
                                    mutate(Mob_Shap = Radiation+
                                                      Adjacency+
                                                      `Air travel`+
                                                      Migration+
                                                      `Friction surface`) %>%
                                    mutate(Driver_Shap = case_when(Env_Shap > Mob_Shap ~ "Env",
                                                                   Mob_Shap > Env_Shap ~ "Mob",
                                                                   Mob_Shap == Env_Shap ~ "Tie"))

#What's the ratio of driver shaps?
  # Note - Only sums to 3679 (since 549 were infected as the intial conditions)
  # Env = 2340 / 3680 = 0.6358696
  # Mob = 1340 / 3680 = 0.3641304

table(shapByInvadedGAUL$Driver_Shap) 

#Plot map
shapByInvadedGAULSpatial <- merge(admin2, shapByInvadedGAUL, by.x="GAUL_CODE", by.y="GAUL", all.x=TRUE)

# save source data
write.csv(shapByInvadedGAUL, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Figure_source_data/SD_Fig_3F.csv")

tm_shape(shapByInvadedGAULSpatial) +
tm_polygons(border.col = "black")+
tm_shape(shapByInvadedGAULSpatial) +
tm_fill("Driver_Shap") +
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")

```

```{r, Plot of driving features over time from contemporary data}
# summarise proportion of invasions for each year that are due to environmental or mobility covariates
timeShap <- table(shapByInvadedGAUL$Driver_Shap, shapByInvadedGAUL$Year_end)
# convert to proportions
timeShap <- apply(timeShap, 2, function(x) c(x[1] / sum(x),
                                             x[2] / sum(x)))
# reshape to long format
timeShap <- data.frame(Subject = rownames(timeShap),
                       timeShap)
timeShap <- reshape(timeShap, idvar = "Subject", varying = list(2:ncol(timeShap)), v.names = "X", direction = "long")
# fix years
timeShap$time = timeShap$time - 1 + min(shapByInvadedGAUL$Year_end)

# save source data
write.csv(timeShap, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Figure_source_data/SD_Fig_3E.csv")

# plotting code
ggplot(timeShap, aes(fill=Subject, y=X, x=time)) + 
    geom_bar(position="fill", stat="identity") +
  scale_fill_manual(values=c(rgb(149/255, 211/255, 199/255), rgb(254/255, 253/255, 174/255))) +
  xlab("Year") +
  ylab("Proportion of invaded municipalities")
```

Time series CV: n-TSCV:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Run naive validation}
seedList = c(1234, 2345, 3456, 4567, 5678, 6789, 7890, 8901, 9012, 10123)

naive_metricsList <- c()
naive_predictionsList <- c() 
naive_metricsList_Regional <- c()
naive_metricsList_Yearly <- c()

thresholds_nTSCV <- predictIncidence(Years = 2002:2019, Country = "Brazil", Current_year = 2020,
                                     mod_sample = FALSE, mod_mode = "CV")
thresholds_nTSCV <- thresholds_nTSCV[, "Incid"]

startTime <- Sys.time()

for (runIndex in 1:10){
  outputs_nTSCV <- naiveTSCV(spread_dat, xgb_pretuned_wflow, randomSeed=seedList[runIndex], country="Brazil", thresholds=thresholds_nTSCV) 
  metrics_nTSCV <- outputs_nTSCV[[1]]
  predictions_nTSCV <- outputs_nTSCV[[2]] %>% dplyr::select(GAUL, Year, .pred_class) %>%
                                              rename(Prediction = .pred_class) %>%
                                              mutate(Seed = seedList[runIndex])
  metrics_nTSCV_Regional <- outputs_nTSCV[[3]]
  metrics_nTSCV_Yearly <- outputs_nTSCV[[4]]
  
  naive_metricsList[[runIndex]] <- metrics_nTSCV
  naive_predictionsList[[runIndex]] <- predictions_nTSCV
  naive_metricsList_Regional[[runIndex]] <- metrics_nTSCV_Regional
  naive_metricsList_Yearly[[runIndex]] <- metrics_nTSCV_Yearly
}

Sys.time() - startTime
#Takes ~1-1.5 hr with 10 random seeds
```

```{r, Plot naive validation}
#Clean up overall data for plotting 
naive_metrics_Overall <- data.frame(matrix(ncol=3,nrow=30, dimnames=list(NULL, c("Run", "Metric", "Value"))))

a <- purrr::flatten(naive_metricsList)
b <- a[seq(3, length(a), 3)]
c <- as.matrix(purrr::flatten(b))

naive_metrics_Overall$Value <- c 
naive_metrics_Overall$Run <- rep(c(1,2,3,4,5,6,7,8,9,10), each=3)
naive_metrics_Overall$Metric <- rep(c("SN","SP","AUC"), each=1)

naive_metrics_Overall %>% unnest(cols = c(Value)) %>%
                          ggplot(aes(x = Metric, y = Value, fill= Metric)) + 
                          geom_boxplot() + theme_bw() +
                          theme(axis.title.x = element_text( face = "bold"),
                                axis.title.y = element_text( face = "bold"),
                                legend.position = "none")+
                          scale_fill_manual(values=c("#FF765A", "#9DB98A", "#7FA3C2"))

# Clean up regional data for plotting 
  ## nrow = n metrics x n regions x n seeds
  ##      = 3 x 5 x 10
naive_metrics_Regional <- data.frame(matrix(ncol=4,nrow=150, dimnames=list(NULL, c("Run", "Region", "Metric", "Value"))))
 
d <- as.matrix(purrr::flatten(naive_metricsList_Regional))
e <- d[-seq(1, length(d), 4)]
f <- as.matrix(purrr::flatten(e))

naive_metrics_Regional$Value <- f 
naive_metrics_Regional$Run <- rep(c(1,2,3,4,5,6,7,8,9,10), each=15)
naive_metrics_Regional$Metric <- c(rep(c("AUC"), each=5),
                                    rep(c("SN"), each=5),
                                    rep(c("SP"),each=5))
naive_metrics_Regional$Region <- rep(c("CW","N","NE", "S", "SE"), each=1)
 
naive_metrics_Regional %>% unnest(cols = c(Value)) %>%
                           ggplot(aes(x = Region, y = Value, fill=Region)) + 
                           geom_boxplot() +
                           facet_wrap(~Metric, scales="free") + theme_bw() +
                           theme(axis.title.x = element_text( face = "bold"),
                                 axis.title.y = element_text( face = "bold"))+
                           scale_fill_brewer(palette="BrBG")

# Clean up yearly data for plotting 
naive_metrics_Yearly <- data.frame(matrix(ncol=4,nrow=540, dimnames=list(NULL, c("Run", "Year", "Metric", "Value"))))

g <- as.matrix(purrr::flatten(naive_metricsList_Yearly))
h <- g[-seq(1, length(g), 4)]
i <- as.matrix(purrr::flatten(h))

naive_metrics_Yearly$Value <- i 
naive_metrics_Yearly$Run <- rep(c(1,2,3,4,5,6,7,8,9,10), each=54)
naive_metrics_Yearly$Metric <- c(rep(c("AUC"), each=18),
                                   rep(c("SN"), each=18),
                                   rep(c("SP"),each=18))
naive_metrics_Yearly$Year <- rep(c("'02","'03","'04", "'05", "'06", "'07",
                                   "'08","'09","'10", "'11", "'12", "'13",
                                   "'14","'15","'16", "'17", "'18", "'19"), each=1)

naive_metrics_Yearly %>% unnest(cols = c(Value)) %>%
                          ggplot(aes(x = Year, y = Value, fill=Metric)) + 
                          geom_boxplot() +
                          facet_wrap(~Metric, scales="free", nrow=3) + 
                          theme_bw()+
                          theme(axis.title.x = element_text( face = "bold"),
                                axis.title.y = element_text( face = "bold"),
                                legend.position = "none")+
                          scale_fill_manual(values=c("#FF765A", "#9DB98A", "#7FA3C2"))

```

```{r, Create dataframe of residuals}
########################################################
# Obtain ground truths on when GAULs became infected ###
########################################################
start_year <- 2001
gtYearInfected <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                                 dplyr::filter(GAUL %in% initialConditions$GAUL) %>% 
                                 dplyr::select(GAUL) %>% 
                                 mutate(YearInfected = start_year) 

#Figure out which GAULs are newly infected each year
for (yearIndex in (1:18)){
  if (yearIndex == 1){
    infectedPriorYear <- gtYearInfected %>% dplyr::select(GAUL)
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }else{
    infectedPriorYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex-1) & Infected == 1) %>% dplyr::select(GAUL) 
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
  gtYearInfected <- rbind(gtYearInfected, newlyInfectedGAULs)
}


#Add in the GAULs that never become infected as NA
neverInfectedGAULS <- spread_dat %>% dplyr::filter(Year_end==2019) %>% dplyr::filter(Infected==0) %>% dplyr::select(GAUL) %>% mutate(YearInfected = NA)
gtYearInfected <- rbind(gtYearInfected, neverInfectedGAULS)

############################################################
# Obtain model predictions on when GAULs became infected ###
############################################################
predictions_nTSCV <- bind_rows(naive_predictionsList) %>% group_by(GAUL) %>% 
                                                          dplyr::filter(Prediction==1) %>% 
                                                          dplyr::filter(Year == min(Year)) %>%
                                                          mutate(MedianYearOverSeeds = median(Year)) %>% 
                                                          dplyr::slice(1) %>% 
                                                          rename(YearPredicted=MedianYearOverSeeds) %>% 
                                                          dplyr::select(GAUL, YearPredicted)

#Left join to get all GAULs in ground truth
joined_nTSCV <- merge(x=gtYearInfected, y=predictions_nTSCV, by="GAUL", all.y=T)

joined_nTSCV <- joined_nTSCV %>% mutate(Residual = YearInfected - YearPredicted) %>% 
                                 mutate(Residual = case_when((is.na(YearInfected) & is.na(YearPredicted)) ~ 0,
                                                             (!is.na(YearInfected) & is.na(YearPredicted)) ~ -20,
                                                             (is.na(YearInfected) & !is.na(YearPredicted)) ~ 20,
                                                             TRUE ~ as.numeric(Residual)))

joinedBinned_nTSCV <- joined_nTSCV %>% mutate(Residual = case_when(Residual > 4 ~ 5,
                                                                   Residual < -4 ~ -5,
                                                                   TRUE ~ as.numeric(Residual)))
#Add region to each GAUL 
joinedBinned_nTSCV$Region = ""
for(i in 1:nrow(joinedBinned_nTSCV)){
  municipality_GAUL <- spread_dat$GAUL[i]
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  joinedBinned_nTSCV$Region[i] <- region_name
}

joinedBinned_nTSCVNoIniCon <- joinedBinned_nTSCV %>% dplyr::filter(!(GAUL %in% initialConditions$GAUL))

```

```{r, Plot residuals as a bargraph }
joinedBinned_nTSCV %>% ggplot(aes(x=Residual, fill=as.factor(Residual))) + 
                 geom_bar(stat="count", colour="black")+theme_bw() +
                 theme(axis.title.x = element_text( face = "bold"),
                       axis.title.y = element_text( face = "bold"),
                       legend.position = "none")+
                 ylab("Number of municipalities with value")+
                 scale_fill_brewer(palette="PuOr")
```

```{r, Plot residuals as calibration curve}
x <- c(2002:2019)
y <- c(2002:2019)
perfectCal <- data.frame(x,y)

joinedBinned_nTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                 ggplot(aes(x=as.factor(YearPredicted), y=YearInfected))+
                 geom_boxplot()+theme_bw()+ggtitle("Calibration - nTSCV Brazil")+
                 xlab("Year Predicted") + ylab("Year Infected")+
                 geom_line(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                 geom_point(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                 scale_y_continuous(breaks=seq(2000,2019,1))

nTSCV_CalPlot_xRug1  <- joinedBinned_nTSCVNoIniCon %>% dplyr::filter(is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                       group_by(YearPredicted) %>%
                                                       tally() %>%
                                                       mutate(InfectionType="Never infected")

nTSCV_CalPlot_xRug2  <- joinedBinned_nTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                       group_by(YearPredicted) %>%
                                                       tally() %>%
                                                       mutate(InfectionType="Infected")

nTSCV_CalPlot_xRug <- rbind(nTSCV_CalPlot_xRug1, nTSCV_CalPlot_xRug2) 
nTSCV_CalPlot_xRug$InfectionType <- factor(nTSCV_CalPlot_xRug$InfectionType, levels=c("Infected", "Never infected"))
nTSCV_CalPlot_xRug %>% ggplot(aes(x=as.factor(YearPredicted),y=n, fill=InfectionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Predicted")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25","firebrick2"))+
                              theme(legend.position="bottom")

nTSCV_CalPlot_yRug1 <- joinedBinned_nTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & is.na(YearPredicted)) %>%
                                                      group_by(YearInfected) %>%
                                                      tally() %>%
                                                      mutate(PredictionType="Never predicted")

nTSCV_CalPlot_yRug2 <- joinedBinned_nTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                      group_by(YearInfected) %>%
                                                      tally() %>%
                                                      mutate(PredictionType="Predicted")

nTSCV_CalPlot_yRug <- rbind(nTSCV_CalPlot_yRug1, nTSCV_CalPlot_yRug2) 
nTSCV_CalPlot_yRug$PredictionType <- factor(nTSCV_CalPlot_yRug$PredictionType, levels = c("Predicted", "Never predicted"))
nTSCV_CalPlot_yRug %>% ggplot(aes(x=as.factor(YearInfected),y=n, fill=PredictionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Infected")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25", "firebrick2"))+
                              theme(legend.position="bottom")
```

```{r, Break down calibration by region as a channel plot}
# Create the different dataframes needed
nTSCV_ChannelDataframes <- createChannelPlotDataframes(joinedBinned_nTSCVNoIniCon)
nTSCV_ChannelDataframe_LineElement <- nTSCV_ChannelDataframes[[1]]
nTSCV_ChannelDataframe_I175 <- nTSCV_ChannelDataframes[[2]]
nTSCV_ChannelDataframe_I195 <- nTSCV_ChannelDataframes[[3]]
nTSCV_ChannelDataframe_PerfectLine <- data.frame(x = 2002:2019, y = 2002:2019, Region = "North")

# Create the two plots
ggplot(data=nTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=nTSCV_ChannelDataframe_I175, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = nTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (IQR) - nTSCV Brazil")

ggplot(data=nTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=nTSCV_ChannelDataframe_I195, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = nTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (1:95th %ile) - nTSCV Brazil")

```

s-TSCV:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Run short-TSCV}
set.seed(202212)
startTime <- Sys.time()

numGAULs <- dim(location_data)[1]

# loop through each year and pre-compute thresholds based on TSCV survival model
thresholds_sTSCV <- list()
for(k in 2002:2019){
  YearIncid <- predictIncidence(Years = k, Country = "Brazil", Current_year = k - 1,
                                mod_sample = FALSE, mod_mode = "CV")
  YearIncid = YearIncid[, "Incid"]
  thresholds_sTSCV = c(thresholds_sTSCV, YearIncid)
}
thresholds_sTSCV = unlist(thresholds_sTSCV)

#Model fitting done successively within the timeseriesCV function
outputs_XGB_TSCV <- timeseriesCV_short(xgb_pretuned_wflow, spread_dat, initialConditions, startYear=2002,
                                      numYears=17, numGAULs=numGAULs, confMatrixGAULs=FALSE, thresholds=thresholds_sTSCV)

metrics_XGB_TSCV <- outputs_XGB_TSCV[[1]]
predictions_XGB_TSCV <- outputs_XGB_TSCV[[2]]

#Plot results
AUC_XGB_TSCV <- ggplot(data = metrics_XGB_TSCV, aes(Year, AUC))+
                geom_jitter(col='seagreen3',width=0.001, height=0)+
                scale_x_continuous(breaks = scales::pretty_breaks(n = 15))+
                theme(legend.position = "none")
 
SP_XGB_TSCV <- ggplot(data = metrics_XGB_TSCV, aes(Year, SP))+
               geom_jitter(col='seagreen3',width=0.001, height=0)+
               scale_x_continuous(breaks = scales::pretty_breaks(n = 15))+
               theme(legend.position = "none")
 
SN_XGB_TSCV <- ggplot(data = metrics_XGB_TSCV, aes(Year, SN))+
               geom_jitter(col='seagreen3',width=0.001, height=0)+
               scale_x_continuous(breaks = scales::pretty_breaks(n = 15))+
               theme(legend.position = "none")
 
tscv_xgb <- AUC_XGB_TSCV / SP_XGB_TSCV / SN_XGB_TSCV + 
            plot_annotation(title = 'Time-series cross-validation on XGBoost model',
                           caption = 'min_n=, tree_depth=, learn_rate=, loss_reduction=, trees=')
tscv_xgb

Sys.time() - startTime
#Takes 1.5 hrs
```

```{r, Figure out what is going on with the mispredictions }
source("Fx_timeseriesCV_short.R")
source("Fx_returnConfMatrixGAULs_sTSCV.R")

numGAULs <- dim(location_data)[1]

sTSCV_confMatGAULs_yr1 <- timeseriesCV_short(xgb_pretuned_wflow, spread_dat, initialConditions, startYear=2002,
                                             numYears=1, numGAULs=numGAULs, country="Brazil", 
                                             leakIncidence = FALSE, confMatrixGAULs=TRUE)

yr1 <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                      mutate(ConfMatStatus = case_when(GAUL %in% sTSCV_confMatGAULs_yr1$truePos$GAUL ~ "TP",
                                                       GAUL %in% sTSCV_confMatGAULs_yr1$trueNeg$GAUL ~ "TN",
                                                       GAUL %in% sTSCV_confMatGAULs_yr1$falsePos$GAUL ~ "FP",
                                                       GAUL %in% sTSCV_confMatGAULs_yr1$falseNeg$GAUL ~ "FN",
                                                       TRUE ~ "PrevInfected"))

yr1 <- merge(admin2, yr1, by.x="GAUL_CODE", by.y="GAUL")

xgb_pretuned_wflow %>% fit(data = (spread_dat %>% dplyr::filter(Year_end == 2002))) %>%
                       pull_workflow_fit() %>% 
                       vi() %>% mutate(Importance = abs(Importance),
                                       Variable = fct_reorder(Variable, Importance)) %>%
                       ggplot(aes(x = Importance, y = Variable)) +
                              geom_col() +
                              scale_x_continuous(expand = c(0, 0)) +
                              labs(y = NULL)

boxplot(LOGimport_pres_Rad~ConfMatStatus, data = yr1)
boxplot(LST_night_mean~ConfMatStatus, data = yr1)
boxplot(LOGimport_pres_Mig~ConfMatStatus, data = yr1)
boxplot(LOGimport_pres_Fric~ConfMatStatus, data = yr1)
boxplot(x~ConfMatStatus, data = yr1)

tm_shape(yr1) +
tm_polygons(border.col = "black") + 
tm_shape(yr1) +
tm_fill("ConfMatStatus", title = paste("Confusion Map - sTSCV Yr 1"))+
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
```

```{r, Create dataframe of residuals}
########################################################
# Obtain ground truths on when GAULs became infected ###
########################################################
start_year <- 2001
gtYearInfected <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                                 dplyr::filter(GAUL %in% initialConditions$GAUL) %>% 
                                 dplyr::select(GAUL) %>% 
                                 mutate(YearInfected = start_year)  

#Figure out which GAULs are newly infected each year
for (yearIndex in (1:18)){
  if (yearIndex == 1){
    infectedPriorYear <- gtYearInfected %>% dplyr::select(GAUL)
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }else{
    infectedPriorYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex-1) & Infected == 1) %>% dplyr::select(GAUL) 
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
  gtYearInfected <- rbind(gtYearInfected, newlyInfectedGAULs)
}


#Add in the GAULs that never become infected as NA
neverInfectedGAULS <- spread_dat %>% dplyr::filter(Year_end==2019) %>% dplyr::filter(Infected==0) %>% dplyr::select(GAUL) %>%  mutate(YearInfected = NA)
gtYearInfected <- rbind(gtYearInfected, neverInfectedGAULS)

############################################################
# Obtain model predictions on when GAULs became infected ###
############################################################
#Bind all the dataframes in the returned list into one
joinedPredictions_XGB_sTSCV <- bind_rows(predictions_XGB_TSCV)

predictionsYearInfected <- joinedPredictions_XGB_sTSCV %>% group_by(GAUL) %>% 
                                                           dplyr::filter(Prediction == 1) %>% 
                                                           dplyr::filter(Year == min(Year)) %>% 
                                                           rename(YearInfected=Year) %>% 
                                                           dplyr::select(GAUL, YearInfected)

#Left join to get all GAULs in ground truth
joined_sTSCV <- merge(x=gtYearInfected, y=predictionsYearInfected, by="GAUL", all.x=T) %>% 
                dplyr::rename(YearInfected = YearInfected.x,
                              YearPredicted = YearInfected.y)

joined_sTSCV <- joined_sTSCV %>% mutate(Residual = YearInfected - YearPredicted) %>% 
                                 mutate(Residual = case_when((is.na(YearInfected) & is.na(YearPredicted)) ~ 0,
                                                             (!is.na(YearInfected) & is.na(YearPredicted)) ~ -20,
                                                             (is.na(YearInfected) & !is.na(YearPredicted)) ~ 20,
                                                             TRUE ~ as.numeric(Residual)))

joinedBinned_sTSCV <- joined_sTSCV %>% mutate(Residual = case_when(Residual > 4 ~ 5,
                                                                   Residual < -4 ~ -5,
                                                                   TRUE ~ as.numeric(Residual)))

#Add region to each GAUL 
joinedBinned_sTSCV$Region = ""
for(i in 1:nrow(joinedBinned_sTSCV)){
  municipality_GAUL <- joinedBinned_sTSCV$GAUL[i]
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  joinedBinned_sTSCV$Region[i] <- region_name
}

joinedBinnedSpatial_sTSCV <- merge(admin2, joinedBinned_sTSCV, by.x="GAUL_CODE", by.y="GAUL")

joinedBinned_sTSCVNoIniCon <- joinedBinned_sTSCV %>% dplyr::filter(!(GAUL %in% initialConditions$GAUL))

```

```{r, Plot year of predicted infection}
map_preds <- tm_shape(joinedBinnedSpatial_sTSCV) +
             tm_polygons(border.col = "black")+ 
             tm_shape(joinedBinnedSpatial_sTSCV) +
             tm_fill("YearPredicted", palette="YlOrRd", title = "Year of predicted invasion",
                     breaks= c(2000, 2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018,2020),
                     textNA = "Dengue not predicted as of 2020")+
             tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold",
                       legend.format=list(fun=function(x) formatC(x, digits=0, format="d")))

map_preds
```

```{r, Plot residuals as a map}
map_residuals <- tm_shape(joinedBinnedSpatial_sTSCV) +
                 tm_polygons(border.col = "black")+ 
                 tm_shape(joinedBinnedSpatial_sTSCV) +
                 tm_fill("Residual", palette="PuOr", n=11, midpoint = 0, style="cat")+
                 tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")

map_residuals
```

```{r, Plot residuals as a bargraph }
joinedBinned_sTSCV %>% ggplot(aes(x=Residual, fill=as.factor(Residual))) + 
                 geom_bar(stat="count", colour="black")+theme_bw() +
                 theme(axis.title.x = element_text( face = "bold"),
                       axis.title.y = element_text( face = "bold"),
                       legend.position = "none")+
                 ylab("Number of municipalities with value")+
                 scale_fill_brewer(palette="PuOr")
```

```{r, Plot residuals as calibration curve}
x <- c(2003:2019)
y <- c(2003:2019)
perfectCal <- data.frame(x,y)

joinedBinned_sTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                               ggplot(aes(x=as.factor(YearPredicted), y=YearInfected))+
                                      geom_boxplot()+theme_bw()+ggtitle("Calibration - sTSCV Brazil")+
                                      xlab("Year Predicted") + ylab("Year Infected")+
                                      geom_line(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                                      geom_point(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                                      scale_y_continuous(breaks=seq(2000,2019,1))

sTSCV_CalPlot_xRug1  <- joinedBinned_sTSCVNoIniCon %>% dplyr::filter(is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                       group_by(YearPredicted) %>%
                                                       tally() %>%
                                                       mutate(InfectionType="Never infected")

sTSCV_CalPlot_xRug2  <- joinedBinned_sTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                       group_by(YearPredicted) %>%
                                                       tally() %>%
                                                       mutate(InfectionType="Infected")

sTSCV_CalPlot_xRug <- rbind(sTSCV_CalPlot_xRug1, sTSCV_CalPlot_xRug2) 
sTSCV_CalPlot_xRug$InfectionType <- factor(sTSCV_CalPlot_xRug$InfectionType, levels=c("Infected", "Never infected"))
sTSCV_CalPlot_xRug %>% ggplot(aes(x=as.factor(YearPredicted),y=n, fill=InfectionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Predicted")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25","firebrick2"))+
                              theme(legend.position="bottom")

sTSCV_CalPlot_yRug1 <- joinedBinned_sTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & is.na(YearPredicted)) %>%
                                                      group_by(YearInfected) %>%
                                                      tally() %>%
                                                      mutate(PredictionType="Never predicted")

sTSCV_CalPlot_yRug2 <- joinedBinned_sTSCVNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                      group_by(YearInfected) %>%
                                                      tally() %>%
                                                      mutate(PredictionType="Predicted")

sTSCV_CalPlot_yRug <- rbind(sTSCV_CalPlot_yRug1, sTSCV_CalPlot_yRug2) 
sTSCV_CalPlot_yRug$PredictionType <- factor(sTSCV_CalPlot_yRug$PredictionType, levels = c("Predicted", "Never predicted"))
sTSCV_CalPlot_yRug %>% ggplot(aes(x=as.factor(YearInfected),y=n, fill=PredictionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Infected")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25", "firebrick2"))+
                              theme(legend.position="bottom")
```

```{r, Break down calibration by region as a channel plot}
# Create the different dataframes needed
sTSCV_ChannelDataframes <- createChannelPlotDataframes(joinedBinned_sTSCVNoIniCon)
sTSCV_ChannelDataframe_LineElement <- sTSCV_ChannelDataframes[[1]]
sTSCV_ChannelDataframe_I175 <- sTSCV_ChannelDataframes[[2]]
sTSCV_ChannelDataframe_I195 <- sTSCV_ChannelDataframes[[3]]
sTSCV_ChannelDataframe_PerfectLine <- data.frame(x = 2001:2019, y = 2001:2019, Region = "North")

# Create the two plots
ggplot(data=sTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=sTSCV_ChannelDataframe_I175, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = sTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (IQR) - sTSCV Brazil")

ggplot(data=sTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=sTSCV_ChannelDataframe_I195, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = sTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (1:95th %ile) - sTSCV Brazil")

```

mTSCV:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Run medium-TSCV}
set.seed(202212)

#Load in intermediate datasets 
setwd("/Users/eideobra/Dropbox/08_Serotype_spread/")
load("Data/Intermediate_datasets/Brazil_Aegypti_sum.RData")
load("Data/Intermediate_datasets/Brazil_EVI_sum.RData")
load("Data/Intermediate_datasets/Brazil_LandCover_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_day_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_night_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCB_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCW_sum.RData")

# remove 2015 values for LST and EVI due to anomalous values not supported by ground observations 
# (annual trend still compensated due to future projection analysis)
Brazil_EVI_sum <- Brazil_EVI_sum[, !grepl("2015", colnames(Brazil_EVI_sum))]
Brazil_LST_day_sum <- Brazil_LST_day_sum[, !grepl("2015", colnames(Brazil_LST_day_sum))]
Brazil_LST_night_sum <- Brazil_LST_night_sum[, !grepl("2015", colnames(Brazil_LST_night_sum))]

# A) simple great circle distance for now
load("Data/Intermediate_datasets/dist_mat_GC_Brazil.RData")
# GC transformation (emphasises close places)
dist_mat_GC = 1 / (dist_mat_GC + 1)
  
 # B) gravity model
load("Data/Intermediate_datasets/Gravity_matrix_Brazil.RData")
  
# c) Radiation model
load("Data/Intermediate_datasets/Radiation_matrix_Brazil.RData")
  
# D) Adjacency model
load("Data/Intermediate_datasets/dist_mat_Adjacency_Brazil.RData")
  
# E) flight data
load("Data/Intermediate_datasets/Brazil_air_move_mat_ad2.RData")
  
# F) Worldpop internal migration flows (state level)
load("Data/Intermediate_datasets/Brazil_Migration_mat.RData")
  
# G) MAP friction surface- travel time between biggest cities in each municiaplity
load("Data/Intermediate_datasets/Brazil_Friction_mat.RData")
# Friction transformation (emphasises accessible places)
dist_mat_Friction = 1 / (dist_mat_Friction + 1)

# exclude self connections in all distance matrices
diag(dist_mat_Adjacency) <- diag(dist_mat_Air) <- diag(dist_mat_Friction) <- NA
diag(dist_mat_GC) <- diag(dist_mat_Grav) <- diag(dist_mat_Migration) <- diag(dist_mat_Rad) <- NA

LST_day_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanDayTemperature_Brazil.csv")
LST_day_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDDayTemperature_Brazil.csv")
LST_night_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanNightTemperature_Brazil.csv")
LST_night_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDNightTemperature_Brazil.csv")
EVI_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanEVI_Brazil.csv")
EVI_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDEVI_Brazil.csv")
TCW_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDTCW_Brazil.csv")
Movement_FP <- read.csv("Data/Intermediate_datasets/Future_pred/Movement_Brazil.csv")

#Load in helper functions
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_suitAssemble.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_addCovariatesBra.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_timeseriesCV_mediumBra.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_minimizeClassificationDistMTSCV.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_computePerformanceMetricsMTSCV.R")

#Model fitting done within the timeseriesCV function
# loop through each year and pre-compute thresholds based on TSCV survival model
thresholds_mTSCV <- list()
for(k in 2002:2019){
  YearIncid <- predictIncidence(Years = k, Country = "Brazil", Current_year = k - 1,
                                mod_sample = FALSE, mod_mode = "CV")
  YearIncid = YearIncid[, "Incid"]
  thresholds_mTSCV = c(thresholds_mTSCV, YearIncid)
}
thresholds_mTSCV = unlist(thresholds_mTSCV)

startTime <- Sys.time()

outputs_medTSCV <- timeseriesCV_mediumBra(xgb_pretuned_wflow, spread_dat, initialConditions, numYears=18, thresholds=thresholds_mTSCV, regions_states_LUT)
metrics_XGB_medTSCV <- outputs_medTSCV[[1]]
predictions_XGB_medTSCV <- outputs_medTSCV[[2]]
probabilities_XGB_medTSCV <- outputs_medTSCV[[3]]

#Plot results
AUC_XGB_year_med <- ggplot(data = metrics_XGB_medTSCV, aes(Year, AUC))+
                    geom_jitter(col='seagreen3',width=0.001, height=0)+
                    scale_x_continuous(breaks = scales::pretty_breaks(n = 13))+
                    theme(legend.position = "none")
 
SP_XGB_year_med <- ggplot(data = metrics_XGB_medTSCV, aes(Year, SP))+
                   geom_jitter(col='seagreen3',width=0.001, height=0)+
                   scale_x_continuous(breaks = scales::pretty_breaks(n = 13))+
                   theme(legend.position = "none")
 
SN_XGB_year_med <- ggplot(data = metrics_XGB_medTSCV, aes(Year, SN))+
                   geom_jitter(col='seagreen3',width=0.001, height=0)+
                   scale_x_continuous(breaks = scales::pretty_breaks(n = 13))+
                   theme(legend.position = "none")
 
tscv_xgb_med <- (AUC_XGB_year_med / SP_XGB_year_med / SN_XGB_year_med) + 
                plot_annotation(title = 'Medium-term time-series cross-validation on XGBoost model')
tscv_xgb_med

Sys.time() - startTime
#Takes ~20 minutes 
```

```{r, Create dataframe of residuals}
########################################################
# Obtain ground truths on when GAULs became infected ###
########################################################
start_year <- 2001
gtYearInfected <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                                 dplyr::filter(GAUL %in% initialConditions$GAUL) %>% 
                                 dplyr::select(GAUL) %>% 
                                 mutate(YearInfected = start_year)  
#Figure out which GAULs are newly infected each year
for (yearIndex in (1:19)){
  if (yearIndex == 1){
    infectedPriorYear <- gtYearInfected %>% dplyr::select(GAUL)
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }else{
    infectedPriorYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex-1) & Infected == 1) %>% dplyr::select(GAUL) 
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
  gtYearInfected <- rbind(gtYearInfected, newlyInfectedGAULs)
}


#Add in the GAULs that never become infected as NA
neverInfectedGAULS <- spread_dat %>% dplyr::filter(Year_end==2019) %>% dplyr::filter(Infected==0) %>% dplyr::select(GAUL) %>% mutate(YearInfected = NA)
gtYearInfected <- rbind(gtYearInfected, neverInfectedGAULS)

############################################################
# Obtain model predictions on when GAULs became infected ###
############################################################

#Add year indices into the list of dataframes returned
start_year <- 2001
for (yearIndex in (1:18)){
  predictions_XGB_medTSCV[[yearIndex]] <- predictions_XGB_medTSCV[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
}

#Bind all the dataframes in the returned list into one
joinedPredictions_XGB_medTSCV <- bind_rows(predictions_XGB_medTSCV)

#Base case is the GAULs in initial conditions
predictionsYearInfected <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                                          dplyr::filter(GAUL %in% initialConditions$GAUL) %>% 
                                          dplyr::select(GAUL) %>% 
                                          mutate(YearInfected = start_year) 

for (yearIndex in (1:18)){
  if (yearIndex == 1){
    infectedPriorYear <- predictionsYearInfected %>% dplyr::select(GAUL)
    infectedThisYear <- joinedPredictions_XGB_medTSCV %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                          dplyr::select(GAUL)
  }else{
    infectedPriorYear <- predictionsYearInfected %>% dplyr::select(GAUL) 
    infectedThisYear <- joinedPredictions_XGB_medTSCV %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                          dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
 predictionsYearInfected <- rbind(predictionsYearInfected, newlyInfectedGAULs)
}

#Left join to get all GAULs in ground truth
joined <- merge(x=gtYearInfected, y=predictionsYearInfected, by="GAUL", all.x=T) %>% 
          dplyr::rename(YearInfected = YearInfected.x,
                        YearPredicted = YearInfected.y) 

joined <- joined %>% mutate(Residual = YearInfected - YearPredicted) %>% 
                     mutate(Residual = case_when((is.na(YearInfected) & is.na(YearPredicted)) ~ 0,
                                                 (!is.na(YearInfected) & is.na(YearPredicted)) ~ -20,
                                                 (is.na(YearInfected) & !is.na(YearPredicted)) ~ 20,
                                                 TRUE ~ as.numeric(Residual)))

joinedBinned <- joined %>% mutate(Residual = case_when(Residual > 4 ~ 5,
                                                       Residual < -4 ~ -5,
                                                       TRUE ~ as.numeric(Residual)))
#Add region to each GAUL 
joinedBinned$Region = ""
for(i in 1:nrow(joinedBinned)){
  municipality_GAUL <- joinedBinned$GAUL[i]
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  joinedBinned$Region[i] <- region_name
}

joinedBinnedSpatial <- merge(admin2, joinedBinned, by.x="GAUL_CODE", by.y="GAUL")


joinedBinnedNoIniCon <- joinedBinned %>% dplyr::filter(!(GAUL %in% initialConditions$GAUL))

#Save residuals to file 
SAVE_RESIDUALS = FALSE
if (SAVE_RESIDUALS == TRUE){
  export <- joinedBinned %>% dplyr::select(GAUL, Residual)
  write.csv(export, "mTSCV-XGB-BrazilToBrazil_Residuals.csv")  
}
```

```{r, Plot year of predicted infection}
map_preds <- tm_shape(joinedBinnedSpatial) +
             tm_polygons(border.col = "black")+ 
             tm_shape(joinedBinnedSpatial) +
             tm_fill("YearPredicted", palette="YlOrRd", title = "Year of predicted invasion",
                     breaks= c(2000, 2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018,2020),
                     textNA = "Dengue not predicted as of 2020")+
             tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold",
                       legend.format=list(fun=function(x) formatC(x, digits=0, format="d")))

map_preds
```

```{r, Plot residuals as a map}
map_residuals <- tm_shape(joinedBinnedSpatial) +
                 tm_polygons(border.col = "black")+ 
                 tm_shape(joinedBinnedSpatial) +
                 tm_fill("Residual", 
                         palette="PuOr",
                         labels= c("-5 (late)", "-4", "-3", "-2", "-1", "0", "1", "2", "3", "4","5 (early)"),
                         n=11, midpoint = 0, style="cat")+
                 tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")

map_residuals
```

```{r, Plot residuals as a bargraph}
joinedBinned %>% ggplot(aes(x=Residual, fill=as.factor(Residual))) + 
                 geom_bar(stat="count", colour="black")+theme_bw() +
                 theme(axis.title.x = element_text(face = "bold", size = 14),
                       axis.title.y = element_text(face = "bold", size = 14),
                       axis.text.x = element_text(size = 12, margin = margin(t = 10, r = 0, b = 6, l = 0)),
                       axis.text.y = element_text(size = 12, margin = margin(t = 0, r = 6, b = 0, l = 0)),
                       legend.position = "none")+
                 ylab("Number of municipalities with value")+
                 scale_x_continuous(breaks = seq(-5,5, by = 1))+
                 scale_fill_brewer(palette="PuOr")
```

```{r, Check to see if the year over year predictions make sense}
createConfusionMap <- function(year){
  preds <- joinedPredictions_XGB_medTSCV %>% dplyr::filter(PredictionYear == year) %>% 
                                             mutate(Infected = as.factor(Infected)) %>%
                                             select(GAUL, Infected) %>%
                                             rename(Prediction = Infected)

  labs <- spread_dat %>% dplyr::filter(Year_end == year) %>%
                         select(GAUL, Infected) %>%
                         rename(Label = Infected)
  #Legend for mapping
    # TN = 0
    # TP = 1
    # FN = 2
    # FP = 3 
  
  confusionDF <- left_join(preds, labs) %>% 
                 mutate(Confusion = case_when(Prediction == 0 & Label == 0 ~ 0,
                                              Prediction == 1 & Label == 1 ~ 1,
                                              Prediction == 0 & Label == 1 ~ 2,
                                              Prediction == 1 & Label == 0 ~ 3)) %>%
                 mutate(Confusion = as.factor(Confusion))
  confusionDF <- merge(admin2, confusionDF, by.x="GAUL_CODE", by.y="GAUL")
  

  confusionMap <- tm_shape(confusionDF) +
                  tm_polygons(border.col = "black") + 
                  tm_shape(confusionDF) +
                  tm_fill("Confusion", title = paste(year, "Confusion Map"), labels=c("TN", "TP", "FN", "FP"))+
                  tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
}

confMap02 <- createConfusionMap(2002)
confMap03 <- createConfusionMap(2003)
confMap04 <- createConfusionMap(2004)
confMap05 <- createConfusionMap(2005)
confMap06 <- createConfusionMap(2006)
confMap07 <- createConfusionMap(2007)
confMap08 <- createConfusionMap(2008)
confMap09 <- createConfusionMap(2009)
confMap10 <- createConfusionMap(2010)

confMap02
confMap03
confMap04
confMap05
confMap06
confMap07
confMap08
confMap09
confMap10
```

```{r, Check variable importance}
xgb_pretuned_wflow %>% fit(data = spread_dat) %>%
                       pull_workflow_fit() %>% 
                       vi() %>% mutate(Importance = abs(Importance),
                                       Variable = fct_reorder(Variable, Importance)) %>%
                       ggplot(aes(x = Importance, y = Variable)) +
                              geom_col() +
                              scale_x_continuous(expand = c(0, 0)) +
                              labs(y = NULL)

```

```{r, Plot residuals as calibration curve}
x <- c(2002:2019)
y <- c(2002:2019)
perfectCal <- data.frame(x,y)

joinedBinnedNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                         ggplot(aes(x=as.factor(YearPredicted), y=YearInfected))+
                         geom_boxplot()+theme_bw()+ggtitle("Calibration - mTSCV Brazil")+
                         xlab("Year Predicted") + ylab("Year Infected")+
                         geom_line(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                         geom_point(data=perfectCal, aes(x=as.factor(x), y=y, group = 1), color="red")+ 
                         scale_y_continuous(breaks=seq(2000,2019,1))


mTSCV_CalPlot_xRug1  <- joinedBinnedNoIniCon %>% dplyr::filter(is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                 group_by(YearPredicted) %>%
                                                 tally() %>%
                                                 mutate(InfectionType="Never infected")

mTSCV_CalPlot_xRug2  <- joinedBinnedNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                 group_by(YearPredicted) %>%
                                                 tally() %>%
                                                 mutate(InfectionType="Infected")

mTSCV_CalPlot_xRug <- rbind(mTSCV_CalPlot_xRug1, mTSCV_CalPlot_xRug2) 
mTSCV_CalPlot_xRug$InfectionType <- factor(mTSCV_CalPlot_xRug$InfectionType, levels=c("Infected", "Never infected"))
mTSCV_CalPlot_xRug %>% ggplot(aes(x=as.factor(YearPredicted),y=n, fill=InfectionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Predicted")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25","firebrick2"))+
                              theme(legend.position="bottom")

mTSCV_CalPlot_yRug1 <- joinedBinnedNoIniCon %>% dplyr::filter(!is.na(YearInfected) & is.na(YearPredicted)) %>%
                                                group_by(YearInfected) %>%
                                                tally() %>%
                                                mutate(PredictionType="Never predicted")

mTSCV_CalPlot_yRug2 <- joinedBinnedNoIniCon %>% dplyr::filter(!is.na(YearInfected) & !is.na(YearPredicted)) %>%
                                                group_by(YearInfected) %>%
                                                tally() %>%
                                                mutate(PredictionType="Predicted")

mTSCV_CalPlot_yRug <- rbind(mTSCV_CalPlot_yRug1, mTSCV_CalPlot_yRug2) 
mTSCV_CalPlot_yRug$PredictionType <- factor(mTSCV_CalPlot_yRug$PredictionType, levels = c("Predicted", "Never predicted"))
mTSCV_CalPlot_yRug %>% ggplot(aes(x=as.factor(YearInfected),y=n, fill=PredictionType)) +
                              geom_bar(stat='identity') +theme_minimal() +
                              xlab("Year Infected")+ylab("Number of municipalities")+
                              scale_fill_manual(values=c("gray25", "firebrick2"))+
                              theme(legend.position="bottom")
```

```{r, Break down calibration by region as a channel plot}
# Create the different dataframes needed
mTSCV_ChannelDataframes <- createChannelPlotDataframes(joinedBinnedNoIniCon)
mTSCV_ChannelDataframe_LineElement <- mTSCV_ChannelDataframes[[1]]
mTSCV_ChannelDataframe_I175 <- mTSCV_ChannelDataframes[[2]]
mTSCV_ChannelDataframe_I195 <- mTSCV_ChannelDataframes[[3]]
mTSCV_ChannelDataframe_PerfectLine <- data.frame(x = 2001:2019, y = 2001:2019, Region = "North")

# Create the two plots
ggplot(data=mTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=mTSCV_ChannelDataframe_I175, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = mTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (IQR) - mTSCV Brazil")

ggplot(data=mTSCV_ChannelDataframe_LineElement, aes(x=x, y=y, group=Region))+
       geom_line(aes(color = Region)) +
       geom_polygon(data=mTSCV_ChannelDataframe_I195, mapping=aes(x=x, y=y, group = Region, fill = Region), alpha = 0.25) +
       geom_line(data = mTSCV_ChannelDataframe_PerfectLine, mapping = aes(x=x, y = y), col = "red", lty = 2) +
       xlab("Year Predicted") +
       ylab("Year Infected") +
       theme_bw()+theme(legend.position="bottom")+
       scale_x_continuous(breaks=seq(2000,2019,1))+
       scale_y_continuous(breaks=seq(2000,2019,1))+
       ggtitle("Channel Plot (1:95th %ile) - mTSCV Brazil")

```

```{r, Examine probabilities of newly invaded GAULs over time}
#Add year indices into the list of dataframes returned
start_year <- 2001
for (yearIndex in (1:18)){
  probabilities_XGB_medTSCV[[yearIndex]] <- probabilities_XGB_medTSCV[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
}
probabilities_XGB_medTSCV <- bind_rows(probabilities_XGB_medTSCV)

probabilities_XGB_medTSCV$Region = ""
for(i in 1:nrow(probabilities_XGB_medTSCV)){
  municipality_GAUL <- probabilities_XGB_medTSCV$GAUL[i]
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  probabilities_XGB_medTSCV$Region[i] <- region_name
}

probabilities_XGB_medTSCV %>% 
  ggplot(aes(x=as.factor(PredictionYear), y=.pred_1))+
        ggbeeswarm::geom_quasirandom()

probabilities_XGB_medTSCV %>% 
  ggplot(aes(x=as.factor(PredictionYear), y=.pred_1))+
        ggbeeswarm::geom_quasirandom(aes(color=Region))+
        theme(legend.position = "bottom")
```

Summarize TSCV:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Reprocess naive TSCV to get means}
naive_meanAUCs <- naive_metrics_Yearly %>% 
                  group_by(Metric) %>% 
                  dplyr::filter(Metric=="AUC") %>% 
                  group_by(Year) %>% 
                  summarise(mean(unlist(Value), na.rm = TRUE)) %>%
                  rename(Value = `mean(unlist(Value), na.rm = TRUE)`)

naive_meanAUCs$Year <- rep(seq(from=2002, to=2019), each=1)
naive_meanAUCs$Metric <- "AUC"

naive_meanSPs <- naive_metrics_Yearly %>% 
                  group_by(Metric) %>% 
                  dplyr::filter(Metric=="SP") %>% 
                  group_by(Year) %>% 
                  summarise(mean(unlist(Value), na.rm = TRUE)) %>%
                  rename(Value = `mean(unlist(Value), na.rm = TRUE)`)

naive_meanSPs$Year <- rep(seq(from=2002, to=2019), each=1)
naive_meanSPs$Metric <- "SP"

naive_meanSNs <- naive_metrics_Yearly %>% 
                  group_by(Metric) %>% 
                  dplyr::filter(Metric=="SN") %>% 
                  group_by(Year) %>% 
                  summarise(mean(unlist(Value), na.rm = TRUE)) %>%
                  rename(Value = `mean(unlist(Value), na.rm = TRUE)`)

naive_meanSNs$Year <- rep(seq(from=2002, to=2019), each=1)
naive_meanSNs$Metric <- "SN"

naive_meanMetrics <- rbind(naive_meanAUCs, naive_meanSPs, naive_meanSNs)
naive_meanMetrics$Type <- "Naive"
```

```{r, Plot naive, short, and medium TSCV together}

metrics_XGB_TSCV$Type <- "Short"
metrics_XGB_medTSCV$Type <- "Medium"

metrics_XGB_combined_TSCV <- rbind(metrics_XGB_TSCV, metrics_XGB_medTSCV) %>% 
                             pivot_longer(! c(ProbThres,Year,Type), names_to = "Metric", values_to ="Value") %>%
                             dplyr::select(-ProbThres)
                                                                   
metrics_XGB_combined_TSCV <- rbind(metrics_XGB_combined_TSCV, naive_meanMetrics )


metrics_XGB_combined_TSCV %>% ggplot(aes(x = Year, y = Value, group=Type)) + 
                              geom_line(aes(color=Type)) + geom_point(aes(color=Type))+
                              facet_wrap(~Metric, scales="free") + theme_bw() +
                              theme(axis.title.x = element_text( face = "bold"),
                                    axis.title.y = element_text( face = "bold"))+
                              scale_color_manual(values = c("#E45197", "#F78520", "#0E336D"))
```

Historical Reconstruction:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Load in data and helper functions}
set.seed(202212)

#Load in intermediate datasets 
setwd("/Users/eideobra/Dropbox/08_Serotype_spread/")
load("Data/Intermediate_datasets/Brazil_Aegypti_sum.RData")
load("Data/Intermediate_datasets/Brazil_EVI_sum.RData")
load("Data/Intermediate_datasets/Brazil_LandCover_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_day_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_night_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCB_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCW_sum.RData")

# remove 2015 values for LST and EVI due to anomalous values not supported by ground observations 
# (annual trend still compensated due to future projection analysis)
Brazil_EVI_sum <- Brazil_EVI_sum[, !grepl("2015", colnames(Brazil_EVI_sum))]
Brazil_LST_day_sum <- Brazil_LST_day_sum[, !grepl("2015", colnames(Brazil_LST_day_sum))]
Brazil_LST_night_sum <- Brazil_LST_night_sum[, !grepl("2015", colnames(Brazil_LST_night_sum))]

# A) simple great circle distance for now
load("Data/Intermediate_datasets/dist_mat_GC_Brazil.RData")
# GC transformation (emphasises close places)
dist_mat_GC = 1 / (dist_mat_GC + 1)
  
 # B) gravity model
load("Data/Intermediate_datasets/Gravity_matrix_Brazil.RData")
  
# c) Radiation model
load("Data/Intermediate_datasets/Radiation_matrix_Brazil.RData")
  
# D) Adjacency model
load("Data/Intermediate_datasets/dist_mat_Adjacency_Brazil.RData")
  
# E) flight data
load("Data/Intermediate_datasets/Brazil_air_move_mat_ad2.RData")
  
# F) Worldpop internal migration flows (state level)
load("Data/Intermediate_datasets/Brazil_Migration_mat.RData")
  
# G) MAP friction surface- travel time between biggest cities in each municiaplity
load("Data/Intermediate_datasets/Brazil_Friction_mat.RData")
# Friction transformation (emphasises accessible places)
dist_mat_Friction = 1 / (dist_mat_Friction + 1)

# exclude self connections in all distance matrices
diag(dist_mat_Adjacency) <- diag(dist_mat_Air) <- diag(dist_mat_Friction) <- NA
diag(dist_mat_GC) <- diag(dist_mat_Grav) <- diag(dist_mat_Migration) <- diag(dist_mat_Rad) <- NA

LST_day_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanDayTemperature_Brazil.csv")
LST_day_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDDayTemperature_Brazil.csv")
LST_night_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanNightTemperature_Brazil.csv")
LST_night_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDNightTemperature_Brazil.csv")
EVI_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanEVI_Brazil.csv")
EVI_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDEVI_Brazil.csv")
TCW_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDTCW_Brazil.csv")
Movement_FP <- read.csv("Data/Intermediate_datasets/Future_pred/Movement_Brazil.csv")

#Load in functions
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_suitAssemble.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_addCovariatesBra.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_historicalReconstruction.R")

#Create look up table for later use 
scenarioLookUpTable <- data.frame(Name = c("RJ 1983", "RJ 1986", "RJ 1989","CE 1986","SP 1990","AM 1996","RR 1998"),
                                  Year=c("1983","1986","1989","1986","1990","1996","1998"),
                                  Mun_name = c("Rio de Janeiro","Rio de Janeiro","Rio de Janeiro",
                                              "Fortaleza","Ribeirao Preto","Manaus","Boa Vista"),
                                  Mun_GAUL = c(9961,9961,9961,7005,11468,6509,10673))

#Train outside the main function
fittedWorkflow <-  xgb_pretuned_wflow %>% fit(data = spread_dat)
```

```{r, Check which Rio source provides the best performance}
possibleRioIntros <-  list(c("RJ 1983"),c("RJ 1986"),c("RJ 1989"))

#Note:  All the Rio sources provide identical results so we are going with the earliest one for now! 
#FIXME: This is a chunk that needs to be manually run for now...
# 3 Jan results- all three scnearios very similar with 1 and 2 indistinguishable and slightly higher stats than scenario 3
scenarioNumber <- 1
scenarioDetails <- as.tibble(unlist(possibleRioIntros[[scenarioNumber]])) %>% rename(Name=1) %>% left_join(., scenarioLookUpTable, by="Name")
scenario_seedingYears <- as.numeric(scenarioDetails$Year)
scenario_seedingGAULs <- as.numeric(scenarioDetails$Mun_GAUL)
scenario_startingYear <- min(scenario_seedingYears)
scenario_numYearsToReconstruct <- 2001-scenario_startingYear
  
#Pull the median thresholds
scenario_thresholds <- list()
for(k in (scenario_startingYear+1):2001){
  YearIncid <- predictIncidence(Years = k, Country = "Brazil", Current_year = k - 1,
                                mod_sample = FALSE, mod_mode = "Best")
  YearIncid = YearIncid[, "Incid"]
  scenario_thresholds = c(scenario_thresholds, YearIncid)
}
scenario_thresholds = unlist(scenario_thresholds)
  
#Run reconstruction
scenario_reconstructionOutputs <- historicalReconstruction(fittedWorkflow = fittedWorkflow, 
                                                           country="Brazil", 
                                                           fullDataset = spread_dat,
                                                           startingYear = scenario_startingYear,
                                                           thresholds = scenario_thresholds,
                                                           seedingYears = scenario_seedingYears,
                                                           seedingGAULs = scenario_seedingGAULs,
                                                           numYears = scenario_numYearsToReconstruct,
                                                           regionLUT = regions_states_LUT)

scenario_outputPredictions <- scenario_reconstructionOutputs[[1]]
scenario_outputProbabilities <- scenario_reconstructionOutputs[[2]]
beep()
```

```{r, Run historical reconstruction with previously identified best Rio source}
chosenRioIntro <- c("RJ 1983")
nonRioSources <- c("CE 1986", "SP 1990", "AM 1996","RR 1998")

scenarios_withoutRio <- c(combn(nonRioSources, 1, simplify = F), combn(nonRioSources, 2, simplify = F), 
                          combn(nonRioSources, 3, simplify = F),combn(nonRioSources, 4, simplify = F))
scenarios_wRio <- lapply(scenarios_withoutRio, function(x) c(chosenRioIntro, x))

#Set up scenario using median thresholds
#FIXME: This is a chunk that needs to be manually run for now...
scenarioNumber <- 3
scenarioDetails <- as_tibble(unlist(scenarios_wRio[[scenarioNumber]])) %>% 
                   rename(Name=1) %>% left_join(., scenarioLookUpTable, by="Name")
scenario_seedingYears <- as.numeric(scenarioDetails$Year)
scenario_seedingGAULs <- as.numeric(scenarioDetails$Mun_GAUL)
scenario_startingYear <- min(scenario_seedingYears)
scenario_numYearsToReconstruct <- 2001-scenario_startingYear
scenario_thresholds <- list()
for(k in (scenario_startingYear+1):2001){
  YearIncid <- predictIncidence(Years = k, Country = "Brazil", Current_year = k - 1,
                                mod_sample = FALSE, mod_mode = "Best")
  YearIncid = YearIncid[, "Incid"]
  scenario_thresholds = c(scenario_thresholds, YearIncid)
}
scenario_thresholds = unlist(scenario_thresholds)
  
#Run reconstruction
scenario_reconstructionOutputs <- historicalReconstruction(fittedWorkflow = fittedWorkflow, 
                                                           country="Brazil", 
                                                           fullDataset = spread_dat,
                                                           startingYear = scenario_startingYear,
                                                           thresholds = scenario_thresholds,
                                                           seedingYears = scenario_seedingYears,
                                                           seedingGAULs = scenario_seedingGAULs,
                                                           numYears = scenario_numYearsToReconstruct,
                                                           regionLUT = regions_states_LUT)

scenario_outputPredictions <- scenario_reconstructionOutputs[[1]]
scenario_outputProbabilities <- scenario_reconstructionOutputs[[2]]
beep()
```

```{r, Assign years of reconstruction}
#Bind all the dataframes in the returned list into one
joinedScenarioOutputPredictions <- bind_rows(scenario_outputPredictions)

#Base case is the GAULs in initial conditions
GAUL <- scenario_seedingGAULs[which(scenario_seedingYears == min(scenario_seedingYears))]
YearInfected <- min(scenario_seedingYears)
historicalReconstructionYearInfected <- data.frame(GAUL, YearInfected)

for (yearIndex in (1:scenario_numYearsToReconstruct)){
  infectedPriorYear <- historicalReconstructionYearInfected %>% dplyr::select(GAUL) 
  infectedThisYear <- joinedScenarioOutputPredictions %>% dplyr::filter(Year==(scenario_startingYear+yearIndex) & Infected == 1) %>% 
                                                          dplyr::select(GAUL)
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (scenario_startingYear+yearIndex))
  
 #Assignment
 historicalReconstructionYearInfected <- rbind(historicalReconstructionYearInfected, newlyInfectedGAULs)
}

allGAULS <- admin2 %>% dplyr::select(GAUL_CODE) %>% st_drop_geometry() %>% rename(GAUL = GAUL_CODE) %>% mutate(GAUL=as.numeric(GAUL))
historicalReconstructionYearInfected <- left_join(allGAULS, historicalReconstructionYearInfected, by="GAUL")
historicalReconstructionYearInfectedSpatial <- merge(admin2, historicalReconstructionYearInfected, by.x="GAUL_CODE", by.y="GAUL")
```

```{r, Plot 2001 ground truth}
#Get initial conditions
initialConditions <- dat %>% dplyr::filter( Year == 2001) %>% dplyr::select(GAUL)
conditions2001 <- initialConditions %>% mutate(Infected=1)
conditions2001 <- left_join(allGAULS, conditions2001, by="GAUL")
conditions2001 <- merge(admin2, conditions2001, by.x="GAUL_CODE", by.y="GAUL")
conditions2001$Infected <- conditions2001$Infected %>% replace_na(0) 

conditions2001 <- conditions2001 %>% mutate(Infected=case_when(Infected==0 ~ "Uninvaded",
                                                               Infected==1 ~ "Invaded"))

tm_shape(conditions2001) +
tm_polygons(col = "black") +
tm_shape(conditions2001) +
tm_fill("Infected", palette = c("#C41E3A", "#D3D3D3"), style = "cat", title = "2001 Ground Truth")+
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
```

```{r, Plot reconstruction as a map}
breaks_histRecon <- c(1983, 1986, 1989, 1992, 1995, 1998, 2001)
textNA_histRecon <- "Dengue not predicted as of 2001"

tm_shape(historicalReconstructionYearInfectedSpatial) +
tm_polygons(border.col = "black")+
tm_shape(historicalReconstructionYearInfectedSpatial) +
tm_fill("YearInfected", palette=brewer.pal(n = 5, name = "YlOrRd"), title = "Predicted invasion year",
        breaks=breaks_histRecon, textNA = textNA_histRecon) +
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold",
          legend.format=list(fun=function(x) formatC(x, digits=0, format="d")))
beep()
```

```{r, Compare reconstruction to 2001 initial conditions}

histPreds <- historicalReconstructionYearInfected %>% mutate(Prediction = case_when(is.na(YearInfected) ~ 0,
                                                                                    !is.na(YearInfected) ~ 1,
                                                                                    TRUE ~ 9999)) %>%
                                                      dplyr::select(GAUL, Prediction)

histLabels <- allGAULS %>% mutate(Label = case_when(allGAULS$GAUL %in% initialConditions$GAUL ~ 1,
                                                    TRUE ~ 0))

histPredsLabs <- left_join(histLabels, histPreds, by="GAUL") %>% mutate(Confusion = case_when((Prediction == 1 & Label == 1) ~ "True Positive",
                                                                                              (Prediction == 0 & Label == 0) ~ "True Negative",
                                                                                              (Prediction == 1 & Label == 0) ~ "False Positive",
                                                                                              (Prediction == 0 & Label == 1) ~ "False Negative",
                                                                                              TRUE ~ ""))

caret::confusionMatrix(as.factor(histPredsLabs$Prediction), 
                       as.factor(histPredsLabs$Label), 
                       positive="1")

```

```{r, Plot confusion map of reconstruction}
textNA_histRecon <- "Dengue not predicted as of 2001"
histPredsLabsSpatial <- merge(admin2, histPredsLabs, by.x="GAUL_CODE", by.y="GAUL")

tm_shape(histPredsLabsSpatial) +
tm_polygons(border.col = "black")+
tm_shape(histPredsLabsSpatial) +
tm_fill("Confusion", title = "2001 Confusion Map",textNA = textNA_histRecon, palette = c("indianred1","firebrick","yellowgreen","forestgreen")) +
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
```

```{r, Check year over year predictions}
createScenarioMap <- function(year){
  scenarioPreds <- joinedScenarioOutputPredictions %>% dplyr::filter(Year == year) %>% 
                                               mutate(Infected = as.factor(Infected)) %>%
                                               select(GAUL, Infected) %>%
                                               rename(Prediction = Infected)
  
  scenarioPlottingDF <- merge(admin2, scenarioPreds, by.x="GAUL_CODE", by.y="GAUL")
  
  scenarioPredsMap <- tm_shape(scenarioPlottingDF) +
                      tm_polygons(border.col = "black") + 
                      tm_shape(scenarioPlottingDF) +
                      tm_fill("Prediction", title = paste(year, "Predictions"),)+
                      tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
  
  return(scenarioPredsMap)
}

map84 <- createScenarioMap(1984)
map85 <- createScenarioMap(1985)
map86 <- createScenarioMap(1986)
map87 <- createScenarioMap(1987)
map88 <- createScenarioMap(1988)
map89 <- createScenarioMap(1989)
map90 <- createScenarioMap(1990)
map91 <- createScenarioMap(1991)
map92 <- createScenarioMap(1992)
map93 <- createScenarioMap(1993)
map94 <- createScenarioMap(1994)
map95 <- createScenarioMap(1995)
map96 <- createScenarioMap(1996)
map97 <- createScenarioMap(1997)
map98 <- createScenarioMap(1998)
map99 <- createScenarioMap(1999)
map00 <- createScenarioMap(2000)
map01 <- createScenarioMap(2001)

map84
map85
map86
map87
map88
map89
map90
map91
map92
map93
map94
map95
map96
map97
map98
map99
map00
map01
```

Future Projections:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Load in data and helper functions}
set.seed(202212)

#Load in intermediate datasets 
setwd("/Users/eideobra/Dropbox/08_Serotype_spread/")
load("Data/Intermediate_datasets/Brazil_Aegypti_sum.RData")
load("Data/Intermediate_datasets/Brazil_EVI_sum.RData")
load("Data/Intermediate_datasets/Brazil_LandCover_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_day_sum.RData")
load("Data/Intermediate_datasets/Brazil_LST_night_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCB_sum.RData")
load("Data/Intermediate_datasets/Brazil_TCW_sum.RData")

# remove 2015 values for LST and EVI due to anomalous values not supported by ground observations 
# (annual trend still compensated due to future projection analysis)
Brazil_EVI_sum <- Brazil_EVI_sum[, !grepl("2015", colnames(Brazil_EVI_sum))]
Brazil_LST_day_sum <- Brazil_LST_day_sum[, !grepl("2015", colnames(Brazil_LST_day_sum))]
Brazil_LST_night_sum <- Brazil_LST_night_sum[, !grepl("2015", colnames(Brazil_LST_night_sum))]

# A) simple great circle distance for now
load("Data/Intermediate_datasets/dist_mat_GC_Brazil.RData")
# GC transformation (emphasises close places)
dist_mat_GC = 1 / (dist_mat_GC + 1)
  
 # B) gravity model
load("Data/Intermediate_datasets/Gravity_matrix_Brazil.RData")
  
# c) Radiation model
load("Data/Intermediate_datasets/Radiation_matrix_Brazil.RData")
  
# D) Adjacency model
load("Data/Intermediate_datasets/dist_mat_Adjacency_Brazil.RData")
  
# E) flight data
load("Data/Intermediate_datasets/Brazil_air_move_mat_ad2.RData")
  
# F) Worldpop internal migration flows (state level)
load("Data/Intermediate_datasets/Brazil_Migration_mat.RData")
  
# G) MAP friction surface- travel time between biggest cities in each municiaplity
load("Data/Intermediate_datasets/Brazil_Friction_mat.RData")
# Friction transformation (emphasises accessible places)
dist_mat_Friction = 1 / (dist_mat_Friction + 1)

# exclude self connections in all distance matrices
diag(dist_mat_Adjacency) <- diag(dist_mat_Air) <- diag(dist_mat_Friction) <- NA
diag(dist_mat_GC) <- diag(dist_mat_Grav) <- diag(dist_mat_Migration) <- diag(dist_mat_Rad) <- NA

LST_day_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanDayTemperature_Brazil.csv")
LST_day_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDDayTemperature_Brazil.csv")
LST_night_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanNightTemperature_Brazil.csv")
LST_night_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDNightTemperature_Brazil.csv")
EVI_m_FP <- read.csv("Data/Intermediate_datasets/Future_pred/MeanEVI_Brazil.csv")
EVI_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDEVI_Brazil.csv")
TCW_sd_FP <- read.csv("Data/Intermediate_datasets/Future_pred/SDTCW_Brazil.csv")
Movement_FP <- read.csv("Data/Intermediate_datasets/Future_pred/Movement_Brazil.csv")

#Load in functions
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_suitAssemble.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_addCovariatesBra.R")
source("/Users/eideobra/Dropbox/08_Serotype_spread/Denspread_code/ModellingSandbox/Fx_futureProjectionsBra.R")
```

```{r, Run future projections}
startTime <- Sys.time()

#Train outside the main function
fittedWorkflow <-  xgb_pretuned_wflow %>% fit(data = spread_dat)

initialConditions2019 <- spread_dat %>% dplyr::filter(Year_end == 2019) %>% dplyr::filter(Infected == 1) %>% dplyr::select(GAUL)
numYearsToProject <- 20

futureThresholds <- predictIncidence(Years = 2020:2039, Country = "Brazil", Current_year = 2019,
                                     mod_sample = TRUE, mod_mode = "CV")

medianThresholds <- futureThresholds[, "Incid"]
lowerBoundThresholds <- futureThresholds[,"Incid_lower"]
upperBoundThresholds <- futureThresholds[,"Incid_upper"]

outputs_futureProjections <- futureProjections(fittedWorkflow = fittedWorkflow, 
                                               country="Brazil", 
                                               fullDataset = spread_dat,
                                               thresholds = medianThresholds,
                                               initialConditions = initialConditions2019, 
                                               numYears = numYearsToProject,
                                               regionLUT = regions_states_LUT)

outputs_futureProjectionsLower <- futureProjections(fittedWorkflow = fittedWorkflow, 
                                               country="Brazil", 
                                               fullDataset = spread_dat,
                                               thresholds = lowerBoundThresholds,
                                               initialConditions = initialConditions2019, 
                                               numYears = numYearsToProject,
                                               regionLUT = regions_states_LUT)
outputs_futureProjectionsUpper <- futureProjections(fittedWorkflow = fittedWorkflow, 
                                               country="Brazil", 
                                               fullDataset = spread_dat,
                                               thresholds = upperBoundThresholds,
                                               initialConditions = initialConditions2019, 
                                               numYears = numYearsToProject,
                                               regionLUT = regions_states_LUT)

futureThresholds_XGB <- outputs_futureProjections[[1]]
futureProjections_XGB <- outputs_futureProjections[[2]]
futureProbabilities_XGB <- outputs_futureProjections[[3]]

futureThresholds_XGBLower <- outputs_futureProjectionsLower[[1]]
futureProjections_XGBLower <- outputs_futureProjectionsLower[[2]]
futureProbabilities_XGBLower <- outputs_futureProjectionsLower[[3]]

futureThresholds_XGBUpper <- outputs_futureProjectionsUpper[[1]]
futureProjections_XGBUpper <- outputs_futureProjectionsUpper[[2]]
futureProbabilities_XGBUpper <- outputs_futureProjectionsUpper[[3]]

Sys.time() - startTime
#Takes ___  30 min 
```

```{r, Assign years of projections}
#Add year indices into the list of dataframes returned
start_year <- 2019
for (yearIndex in (1:numYearsToProject)){
  futureProjections_XGB[[yearIndex]] <- futureProjections_XGB[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
  
  futureProjections_XGBLower[[yearIndex]] <- futureProjections_XGBLower[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
  
  futureProjections_XGBUpper[[yearIndex]] <- futureProjections_XGBUpper[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
}

#Bind all the dataframes in the returned list into one
joinedFutureProjections_XGB <- bind_rows(futureProjections_XGB)
joinedFutureProjections_XGBLower <- bind_rows(futureProjections_XGBLower)
joinedFutureProjections_XGBUpper <- bind_rows(futureProjections_XGBUpper)

#Base case is the GAULs in initial conditions
futurePredictionsYearInfected <- initialConditions2019 %>% mutate(YearInfected = start_year) 
futurePredictionsYearInfectedLower <- initialConditions2019 %>% mutate(YearInfected = start_year)
futurePredictionsYearInfectedUpper <- initialConditions2019 %>% mutate(YearInfected = start_year)

for (yearIndex in (1:numYearsToProject)){
  if (yearIndex == 1){
    infectedPriorYear <- futurePredictionsYearInfected %>% dplyr::select(GAUL)
    infectedPriorYearLower <- futurePredictionsYearInfectedLower %>% dplyr::select(GAUL)
    infectedPriorYearUpper <- futurePredictionsYearInfectedUpper %>% dplyr::select(GAUL)
    
    infectedThisYear <- joinedFutureProjections_XGB %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                          dplyr::select(GAUL)
    infectedThisYearLower <- joinedFutureProjections_XGBLower %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                        dplyr::select(GAUL)
    infectedThisYearUpper <- joinedFutureProjections_XGBUpper %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                        dplyr::select(GAUL)
    
  }else{
    infectedPriorYear <- futurePredictionsYearInfected %>% dplyr::select(GAUL)
    infectedPriorYearLower <- futurePredictionsYearInfectedLower %>% dplyr::select(GAUL)
    infectedPriorYearUpper <- futurePredictionsYearInfectedUpper %>% dplyr::select(GAUL)
    
    infectedThisYear <- joinedFutureProjections_XGB %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                        dplyr::select(GAUL)
    infectedThisYearLower <- joinedFutureProjections_XGBLower %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                        dplyr::select(GAUL)
    infectedThisYearUpper <- joinedFutureProjections_XGBUpper %>% dplyr::filter(PredictionYear==(start_year+yearIndex) & Infected == 1) %>% 
                                                        dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  newlyInfectedGAULsLower <- dplyr::setdiff(infectedThisYearLower, infectedPriorYearLower) %>% mutate(YearInfected = (start_year+yearIndex))
  newlyInfectedGAULsUpper <- dplyr::setdiff(infectedThisYearUpper, infectedPriorYearUpper) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
 futurePredictionsYearInfected <- rbind(futurePredictionsYearInfected, newlyInfectedGAULs)
 futurePredictionsYearInfectedLower <- rbind(futurePredictionsYearInfectedLower, newlyInfectedGAULsLower)
 futurePredictionsYearInfectedUpper <- rbind(futurePredictionsYearInfectedUpper, newlyInfectedGAULsUpper)
}

allGAULS <- admin2 %>% dplyr::select(GAUL_CODE) %>% st_drop_geometry() %>% rename(GAUL = GAUL_CODE) %>% mutate(GAUL=as.numeric(GAUL))
futurePredictionsYearInfected <- left_join(allGAULS, futurePredictionsYearInfected, by="GAUL")
futurePredictionsYearInfected <- left_join(futurePredictionsYearInfected, futurePredictionsYearInfectedLower, by="GAUL")
futurePredictionsYearInfected <- left_join(futurePredictionsYearInfected, futurePredictionsYearInfectedUpper, by="GAUL")
names(futurePredictionsYearInfected)[2:4] = c("YearInfected", "YearInfectedLower", "YearInfectedUpper")

futurePredictionsYearInfectedSpatial <- merge(admin2, futurePredictionsYearInfected, by.x="GAUL_CODE", by.y="GAUL")
```

```{r, Plot projections as a map}
palette_FutureProj <- brewer.pal(n = 5, name = "YlOrRd")
palette_FutureProj <- c("#FFFFFF", palette_FutureProj)

if (numYearsToProject == 5){
  breaks_futureProj <- c(2019, 2020, 2021, 2022, 2023, 2024, 2025)
  labels_futureProj <- c("Before 2020", "2020", "2021", "2022","2023", "2024")
  textNA_futureProj <- "Dengue not predicted as of 2024"
}else if (numYearsToProject == 10){
  breaks_futureProj <- c(2019, 2020, 2022, 2024, 2026, 2028, 2029)
  labels_futureProj <- c("Before 2020", "2020-2022", "2022-2024", "2024-2026","2026-2028", "2028-2029")
  textNA_futureProj <- "Dengue not predicted as of 2029"
}else if (numYearsToProject == 15){
  breaks_futureProj <- c(2019, 2020, 2023, 2026, 2029, 2032, 2034)
  labels_futureProj <- c("Before 2020", "2020-2023", "2023-2026", "2026-2029","2029-2032", "2032-2034")
  textNA_futureProj <- "Dengue not predicted as of 2034"
}else if(numYearsToProject == 20){
  breaks_futureProj <- c(2019, 2020, 2024, 2028, 2032, 2036, 2039)
  labels_futureProj <- c("Before 2020", "2020-2024", "2024-2028", "2028-2032","2032-2036", "2036-2039")
  textNA_futureProj <- "Dengue not predicted as of 2039"
}

tm_shape(futurePredictionsYearInfectedSpatial) +
tm_polygons(border.col = "black")+
tm_shape(futurePredictionsYearInfectedSpatial) +
tm_fill("YearInfected", palette=palette_FutureProj, title = "Predicted invasion year",
        breaks= breaks_futureProj, labels=labels_futureProj, textNA = textNA_futureProj) +
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold",
          legend.format=list(fun=function(x) formatC(x, digits=0, format="d")))
```

```{r, Examine probabilities of newly invaded GAULs over time}
#Add year indices into the list of dataframes returned
start_year <- 2019
for (yearIndex in (1:numYearsToProject)){
  futureProbabilities_XGB[[yearIndex]] <- futureProbabilities_XGB[[yearIndex]] %>% mutate(PredictionYear=(start_year + yearIndex))
}
futureProbabilities_XGB <- bind_rows(futureProbabilities_XGB)

futureProbabilities_XGB$Region = ""
for(i in 1:nrow(futureProbabilities_XGB)){
  municipality_GAUL <- futureProbabilities_XGB$GAUL[i]
  admin2_index <- match(municipality_GAUL, admin2$GAUL_CODE)
  state_GAUL <- admin2[admin2_index,]$PARENT_ID
  admin1_index <- match(state_GAUL, admin1$GAUL_CODE)
  state_name <- admin1$NAME[admin1_index]
  region_name <- unname(getRegion[state_name])
  futureProbabilities_XGB$Region[i] <- region_name
}

futureProbabilities_XGB %>% 
  ggplot(aes(x=as.factor(PredictionYear), y=.pred_1))+
        ggbeeswarm::geom_quasirandom()

futureProbabilities_XGB %>% 
  ggplot(aes(x=as.factor(PredictionYear), y=.pred_1))+
        ggbeeswarm::geom_quasirandom(aes(color=Region))+
        theme(legend.position = "bottom")
```

```{r, Bar graph with number of invaded GAULs from 2000-2040}
start_year <- 2001
gtYearInfected <- spread_dat %>% dplyr::filter(Year_end == 2002) %>% 
                                 dplyr::filter(GAUL %in% initialConditions$GAUL) %>% 
                                 dplyr::select(GAUL) %>% 
                                 mutate(YearInfected = start_year) 

#Figure out which GAULs are newly infected each year
for (yearIndex in (1:18)){
  if (yearIndex == 1){
    infectedPriorYear <- gtYearInfected %>% dplyr::select(GAUL)
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }else{
    infectedPriorYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex-1) & Infected == 1) %>% dplyr::select(GAUL) 
    infectedThisYear <- spread_dat %>% dplyr::filter(Year_end==(start_year+yearIndex) & Infected == 1) %>% dplyr::select(GAUL)
  }
  
  newlyInfectedGAULs <- dplyr::setdiff(infectedThisYear, infectedPriorYear) %>% mutate(YearInfected = (start_year+yearIndex))
  
  #Assignment
  gtYearInfected <- rbind(gtYearInfected, newlyInfectedGAULs)
}


#Add in the GAULs that never become infected as NA
neverInfectedGAULS <- spread_dat %>% dplyr::filter(Year_end==2019) %>% dplyr::filter(Infected==0) %>% dplyr::select(GAUL) %>% mutate(YearInfected = NA)
gtYearInfected <- rbind(gtYearInfected, neverInfectedGAULS)

infected2000to2039 <- rbind(futurePredictionsYearInfected[, 1:2] %>% dplyr::filter(YearInfected > 2019), 
                            gtYearInfected %>% dplyr::filter(!is.na(YearInfected))) %>%
                      mutate(TimeSeries = case_when(YearInfected <2020 ~ "Contemporary Spread",
                                                    YearInfected > 2019 ~ "Future Projection"))

muns_year <- table(infected2000to2039$YearInfected)
muns_year <- data.frame(Year = as.numeric(names(muns_year)),
                        Municipalities = cumsum(muns_year)) %>%
             mutate(TimeSeries = case_when(Year < 2020 ~ "Contemporary Spread",
                                           Year > 2019 ~ "Future Projection"))

muns_year %>% ggplot(aes(x = Year, y = Municipalities, fill=TimeSeries)) + 
                       geom_bar(stat="identity", colour="black")+theme_bw() +
                       scale_y_continuous(name = "Cumulative municipalities", limits = c(0, nrow(admin2))) +
                       theme(axis.title.x = element_text( face = "bold"),
                             axis.title.y = element_text( face = "bold"),
                             legend.position = "bottom")+
                       labs(fill="Time Period")+
                       ylab("Cumulative municipalities")+
                       scale_fill_manual(values=c("Contemporary Spread"="white",
                                                  "Future Projection"="firebrick"))
```

```{r, Determine the 10 largest future infected municipalities}
Brazil_Population <- read.csv("/Users/eideobra/Dropbox/08_Serotype_spread/Data/Population/Brazil_pop.csv") %>% 
                     dplyr::select(GAUL_CODE, Pop) %>% 
                     rename(GAUL=GAUL_CODE)

futurePredictionsYearInfected <- base::merge(futurePredictionsYearInfected, Brazil_Population)

top10FutureInfectedGAULs <- futurePredictionsYearInfected %>% dplyr::filter(YearInfected > 2019) %>% 
                                                              arrange(desc(Pop)) %>% 
                                                              slice_max(Pop, n=10) %>% 
                                                              dplyr::select(-c(Pop))

outputs_futureProjections_wBigCities <- futureProjections(fittedWorkflow = fittedWorkflow, 
                                                          country="Brazil", 
                                                          fullDataset = spread_dat,
                                                          thresholds = medianThresholds,
                                                          initialConditions = initialConditions2019, 
                                                          numYears = numYearsToProject,
                                                          big_cities = top10FutureInfectedGAULs,
                                                          regionLUT = regions_states_LUT)

bigCityMobilityMatrices <- outputs_futureProjections_wBigCities[[4]] %>% discard(is.null)
```

Generate megamap:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, All years combined}
# Combine predictions from mTSCV and future projections together
megamap_historicalGAULs <- historicalReconstructionYearInfected %>% rename(HistoricallyInfected=YearInfected) 

megamap_currentGAULs <- joinedBinned %>% dplyr::select(GAUL, YearPredicted) %>% 
                                         rename(CurrentlyInfected=YearPredicted) 

megamap_futureGAULs <- futurePredictionsYearInfected %>% dplyr::filter(YearInfected > 2019) %>%
                                                         rename(FutureInfected=YearInfected) 

megamap_currentFutureGAULs <- merge(megamap_currentGAULs, megamap_futureGAULs, by="GAUL", all.x=T)
                              
megamap_allGAULs <- merge(megamap_historicalGAULs, megamap_currentFutureGAULs, by="GAUL", all.x=T) %>%
                    mutate(YearInfected = coalesce(HistoricallyInfected, CurrentlyInfected, FutureInfected))

megamap_spatial <- merge(admin2, megamap_allGAULs, by.x="GAUL_CODE", by.y="GAUL", all.x=TRUE)

#Plot megamap
palette_megamap <- brewer.pal(n = 10, name = "YlOrRd")
palette_megamap <- c("#FFFFFF", palette_megamap)

breaks_megamap <- c(1986, 1991, 1996, 2001, 2006, 2011, 2016, 2021, 2026, 2031, 2036, 2039)
labels_megamap <- c("1986-1991", "1991-1996", "1996-2001", "2001-2006", "2006-2011", 
                    "2011-2016","2016-2021", "2021-2026", "2026-2031","2031-2036","2036-2039")
textNA_megamap <- "Dengue not predicted as of 2039"

tm_shape(megamap_spatial) +
tm_polygons(border.col = "black")+
tm_shape(megamap_spatial) +
tm_fill("YearInfected", palette=palette_megamap, title = "Predicted invasion year",
        breaks= breaks_megamap, labels=labels_megamap, textNA = textNA_megamap, showNA = TRUE) +
tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold",
          legend.format=list(fun=function(x) formatC(x, digits=0, format="d")))
```

```{r, Plot each year on a different map}
start_time <- Sys.time()
textNA_yearOverYearMegamap <- "Dengue not predicted as of current year"

for (yearIndex in 1986:2039){
  yearOverYearMegamap_allGAULs <- megamap_allGAULs %>% dplyr::select(GAUL, YearInfected) %>%
                                                       mutate(currentlyInfected = case_when(YearInfected<=yearIndex ~ "Invaded",
                                                                                            TRUE ~ "Uninvaded"))
  
  yearOverYearMegamap_spatial <- merge(admin2, yearOverYearMegamap_allGAULs, by.x="GAUL_CODE", by.y="GAUL", all.x=TRUE)
  
  yearOverYearMegamap <- tm_shape(yearOverYearMegamap_spatial) +
                         tm_polygons(border.col = "black")+
                         tm_shape(yearOverYearMegamap_spatial) +
                         tm_fill("currentlyInfected", title = paste("Invaded GAULs as of", yearIndex), palette = c("red", "grey")) +
                         tm_layout(frame = FALSE, legend.outside = TRUE, legend.title.fontface = "bold")
  
  yearOverYearMegamap_filename <- paste("/Users/vinyas/Desktop/Brazil-megamapYOY_", yearIndex,".jpg", sep="")
  tmap_save(yearOverYearMegamap, yearOverYearMegamap_filename)
}
end_time <- Sys.time()
end_time - start_time

#Takes ~55 min on the Mac Studio, faster than Mexico somehow??
```

Save files for Oli:\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~\~

```{r, Write to desktop}
#mTSCV of contemporary spread (Fig 1)
write.csv(joined, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig1-ContemporaryPredsJan24.csv") 

# Ground truth for historical predictions, note the historical reconstruction block above needs to be run 2x
write.csv(conditions2001, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig2-GroundTruth2001Jan24.csv") 
#write.csv(historicalReconstructionYearInfected, file = #"/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig2-S0-Rio83Jan24.csv")
write.csv(historicalReconstructionYearInfected, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig2-S6-RioFortManJan24.csv")

#Future predictions (Fig 3) and wargames (Fig 4)
write.csv(futurePredictionsYearInfected, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig3-FuturePredsJan24.csv")
write.csv(top10FutureInfectedGAULs, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig4-Top10FutureInfected-GAULsJan24.csv")
save(bigCityMobilityMatrices, file = "/Users/eideobra/Dropbox/08_Serotype_spread/Predictions/Bra-Fig4-Top10FutureInfected-MobMatricesJan24.RData")

```
